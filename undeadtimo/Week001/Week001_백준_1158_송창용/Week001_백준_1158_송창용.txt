이해를 위한 것.

7, 3에 대해서

1 2 3 4 5 6 7
1부터 시작해서 3번째는 3
3 제거

1 2 4 5 6 7
4부터 시작해서 3번째는 6
6제거

1 2 4 5 7
7부터 시작해서 3번째는 2
2제거

1 4 5 7
4부터 시작해서 3번째는 7
7제거

1 4 5
1부터 시작해서 3번째는 5
5제거

1부터 시작해서 3번째는 1
1제거

마지막 남은 것은 4뿐임 4
4제거

3, 6, 2, 7, 5 ,1, 4


이 예시에서 규칙을 찾아보자.
어려운데?

arrayList로 생각해볼까? 자동으로 길이가 맞춰지는 arrayList의 특성과 잘 맞아떨어질 것 같다.
k가 3이니까
첫 번째 두 번째 세 번째 숫자를 세서 3번째 숫자를 제거했어.
아, 아니다 일반 배열이 더 편하겠다.
제거의 의미로 3번째 숫자를 제거하고, (0으로 만들고)
다음 인덱스부터 출발하도록 하려면 배열로 하는게 논리적으로 구현하는 것이 편하겠다.

while문을 통해서
반복할 때마다 증가하는 숫자 i를 지정해주자(0에서 시작).
(i + 1)이 k의 배수가 될 때마다(문제에서 몇 번째를 셀 때는 1부터 시작하니까) 해당 인덱스에 위치한 값을 출력을 위한 배열(int[] total = new int[N])에 넣어주고 대신 해당 인덱스 자리에 0을 넣어준다.
i가 N보다 같거나 커지면 어떻게 하느냐?
i를 N으로 %해주면 된다.

그렇게 반복문을 돌리면서
i + 1이 k의 배수가 될 때에 해당하는 조건문이 몇 번 반복되었는지 측정할 cnt값을 지정해서
cnt값이 N과 동일해지면 break하도록 만들고,
출력을 위한 배열에서 첫 번째 요소부터 출력하도록 만들면 해결이다! 

잠깐!!!!
0으로 만들어준 요소들은 없어진 것처럼 취급해야 하니
만약 해당 값이 0인 인덱스에 도달하면 위치값을 그대로 만들어주기 위해 조건문을 설정해서 iterator값을 --해줘야겠다!




1, 2, 3, 4, 5, 6, 7

1, 2, 0, 4, 5, 6, 7

1, 2, 0, 4, 5, 0, 7

1, 0, 0, 4, 5, 0, 7












