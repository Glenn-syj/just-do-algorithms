# [Silver IV] 요세푸스 문제 - 1158 

## 나의 로직 🧐

<p>먼저 문제를 이해하고 패턴을 찾아내기 위해, 예시를 따라해보았다.</p>

```
[1, 2, 3, 4, 5, 6, 7]
# 번호를 부여한 7명의 사람이 있다고 가정하고, 
# 3명씩 셀 때 마다 해당 번호의 사람을 죽인다면,
<3, 6, 2, 7, 5, 1, 4> 순서대로 사람이 죽는다.

직접 해보자,
[1, 2, 3, 4, 5, 6, 7]
1, 2, 3...
3을 죽인다.

[1, 2, x, 4, 5, 6, 7] 남은 사람 목록
<3, 0, 0, 0, 0, 0, 0> 죽은 사람 목록

4, 5, 6...
6을 죽인다.
[1, 2, x, 4, 5, x, 7] 남은 사람 목록
<3, 6, 0, 0, 0, 0, 0> 죽은 사람 목록

... ...
...

모두 죽였다.
<3, 6, 2, 7, 5, 1, 4> 순서대로...
```

+  사람이 죽을 때마다 죽은 사람을 목록에서 제거하고 있기 때문에,
    + 처음에는 자동적으로 크기가 조정되는 ***arrayList***를 사용해보자고 생각했다.

* 그러나 탐색을 위한 index를 조정하는 과정이 arrayList를 사용하는 것보다,
    + 일반 배열을 사용하면서, '***죽은 사람의 자리에 0을 넣어두는 것***'이 더 구현하기 쉬울 것이라 판단하여 계획을 바꾸었다.

### 배열을 다시 처음부터 탐색하려면 어떻게 하지? 😵‍💫
+ 내가 생각한 것은 index값으로 쓰이며 계속해서 증가하는 iterator값(i : 반복자)을 배열의 크기로 나눈 나머지로 만들어주는 방법이었다.

<p>7명의 사람이 들어있는 배열
[1, 2, 3, 4, 5, 6, 7]에서
people[i] 형식을 통해서
people[0] 부터 people[6]까지 탐색한 이후,</p>

+ 원래라면 ***i값은 계속 증가하기 때문에*** 다음으로 people[7]을 탐색하게 될 것이다.

그러나 i값을 7로 나눈 나머지로 만들어준다면

```
iterator = iterator % 7;
```

<p>people[6] 탐색을 마치고 나서, 
다시 people[0]을 탐색하게 된다.</p>

## 시도 후 고민 😨

+ 나는 두 가지에 대해 잘못을 저질렀다.

---

1. iterator값을 다루면서 이미 죽인 사람들의 자리를 count하지 않기 위해 people[iterator] == 0 이면 iterator-- 를 해서 iterator를 감소시켜야겠다!

---

+ 라는 이상한 생각을 했다. 
    + 0값을 넣어준 죽은 사람의 위치를 탐색하면
    + iterator가 1 감소하고, 원래 반복문에서 설정해놓은 iterator++가 또 실행되면서 다시 iterator가 1 증가했다.
    + 즉, 계속해서 같은 자리만 탐색하게 되어서 무한루프에 빠졌다.

이 문제는 *'k번째로 사람을 셀 때마다 죽인다'* 라는 규칙에서 

주어지는 k를 jump변수에 할당하고, 

jumpCnt라는 변수에 0을 할당하여 해결했다. 🥳🥳🥳

```
int jump = k;
int jumpCnt = 0;
```
반복하면서 ***만나는 숫자들이 0이 아닐 경우에만*** jumpCnt++를 해주었다.

그리고 jumpCnt % k == 0 이라는 조건을 통해

k번째 사람이구나를 파악하여 사람을 죽이도록 했다.

---

2. 모든 것을 해결하여 이제 끝이라고 생각했으나, 무려 99%에서 오답판정을 받았다.
---
### 도대체 어디가 잘못된거야 😡

+ 반례를 찾기 위해 여러 입력값을 넣어보았다.
+ 그러나 모두 올바른 출력값을 내놓았다.
+ 5000명을 5000번 셀 때마다 1명씩 죽여보았지만,
+ 그것조차 올바른 출력값을 보여주었다.

...

반복적으로 코드를 제출하는데, 눈에 띄는 것이 있었다.

채점이 시작된 초반부분에는 시간이 굉장히 오래걸렸다.

그러나 끝으로 갈수록 빠른 속도로 채점이 되었다.

어쩌면, 5000명을 5000번 셀 때마다 죽이는 케이스처럼

많은 시간이 요구되는 케이스를 먼저 확인하고,

적은 시간이 요구되는 케이스를 나중에 검증하는 것이 아닐까?

그렇다면 99%에서 틀린다는 것은...

나는 입력값으로 1, 1을 넣어보았고,
```
<1 ,
```
<1>이 출력되어야할 그곳에 <1 , 이 출력되고 있었다.

### 나는 죽은 사람이 한 명일 때의 조건을 따로 만들어주었고, 
### 더 이상 사람을 죽이지 않아도 되었다. 
### 😎


---



[문제 링크](https://www.acmicpc.net/problem/1158) 

### 성능 요약

메모리: 44752 KB, 시간: 3048 ms

### 분류

자료 구조, 구현, 큐

### 제출 일자

2024년 1월 27일 23:24:14

### 문제 설명

<p>요세푸스 문제는 다음과 같다.</p>

<p>1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.</p>

<p>N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000)</p>

### 출력 

 <p>예제와 같이 요세푸스 순열을 출력한다.</p>

