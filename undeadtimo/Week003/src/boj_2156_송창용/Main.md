# [Silver I] 포도주 시식 - 2156 

[문제 링크](https://www.acmicpc.net/problem/2156) 


## 나의 로직 🧐

문제를 풀기위해 문제를 푸는 것을 포기했다.

<b><span style="font-size:130%">...?</span></b>

## 와라! 다이나믹 프로그래밍! DP!

+ 그 유명한 DP를 만났다.

___dp? 그게 뭔데? 탈영병 잡으러가는 부대??___ <b><span style="font-size:130%">😬</span></b>

## Dynamic programming

 ___"뭔가 멋있게 부르고 싶어서 Dynamic을 붙였습니다."___ 

<b><span style="font-size:130%"> - [ Richard E. Bellman ] 🤓</span></b> 

---
응용수학자인 벨만씨 덕분에 해괴망측한 문제들을 많이 풀게 되었다!

감사하는 마음으로 DP를 알아보자! <b><span style="font-size:130%">😍😍😍</span></b>

---

DP, 일명 ___'동적 프로그래밍'___ 은 흔히 ___'동적 계획법'___ 이라고 더 많이 부른다.

### '동적 계획법' 
+ 주어진 문제를 ___'작은 문제들로 나눈뒤'___ 각 작은 문제들에서 얻은 답을 통해 주어진 문제의 답을 도출해내는 ___'분할 정복'___ 의 방식에서

+ 특정한 '작은 문제'가 두 번 이상 ___'반복'___ 될 때, 이전에 한 번 계산할 때 ___'도출했던 답'___ 을 재활용 하는 방식을 추가한 것이다. 

<b><span style="font-size:130%">아니 그래서 어떻게 하는 건데...😩👹👾</span></b>

술이 땡기는 바람에<b><span style="font-size:130%"> 😜</span></b> 선택한 '포도주 시식🍷' 문제로 돌아와보자.

여러 와인잔🍸에는 각각의 와인량🍹이 무작위하게 들어있다.

근데 이런! 😮‍💨 

놓여있는 와인잔 중에서 ___'세 잔 이상의 와인을 연속으로 마실 수 없다!'___

---

엥... <b><span style="font-size:130%">😨</span></b> 

패턴은 내가 알아서 찾아야 하는거야??<b><span style="font-size:130%">😱</span></b>

dp는 뭔데...

---

### dp는 말이야?! <b><span style="font-size:130%">😎</span></b>

___bottom-up___ 과 ___top-down___ 두 종류가 있어!

+ bottom-up 이란 for문을 이용해서,
    + dp배열의 첫 번째 요소부터 채워나가는 것이고

+ top-down 이란 재귀함수를 이용해서
    + dp배열의 마지막 요소부터 힙영역에 올려놓는 것이야!

그... 그게 다야? <b><span style="font-size:130%">🤔</span></b>

이... 이게 다야! <b><span style="font-size:130%">🤡</span></b>

---

### 좋아! 패턴을 직접 찾아보자!

우선 포도주 문제에서 주어진 예시를 가져오자.
```
[6, 10, 13, 9, 8, 1]
```
와인이 하나만 존재할 때부터 생각해보자구!

🍷 [6] 

6의 양을 가진 와인 하나만 존재한다고 생각하면,

최대로 마실 수 있는 와인량은 6이겠지!

좋아좋아! 할만해! <b><span style="font-size:130%">😆</span></b>


🍷🍸 [6, 10] (^)

6과 10에 해당하는 와인이 존재한다고 간주한다면,

최대로 마실 수 있는 와인량은 6 + 10인 16이겠지!

계속해! Keep going! <b><span style="font-size:130%">😄</span></b>

🍷🍸🍹
[6, 10, 13]

세 개의 와인이 있을 때, 최대로 마실 수 있는 와인량은...

6 + 13, 아니고

6 + 10, (^) 아니고

10 + 13, (&) 이거다! 23이야! 휴...

<b><span style="font-size:130%">😃</span></b>

🍷🍸🍹🍷
[6, 10, 13, 9]

네 개의 와인이 있을 때

........... <b><span style="font-size:130%">😀</span></b>

후... 해보자.

+ 6 + 10 + 9 = 25

+ 6 + 13 + 9 = 28 (*)

+ 10 + 13 = 23 (&)

와인을 마시는 경우들을 가져와서 비교해보니 28이 가장 크네! 

<b><span style="font-size:130%">취한다... 🤪</span></b>

🍷🍸🍹🍷🍸
[6, 10, 13, 9, 8]

다섯 개의 와인이 있을 때

<b><span style="font-size:130%">아아악......</span></b>


+ 6 + 10 + 9 + 8 = 33

+ 10 + 13 + 8 = 31

+ 6 + 13 + 9 = 28 (*)

여기서는 33이 최대값이야!! 휴 힘들다! <b><span style="font-size:130%">😹</span></b>

---

<b><span style="font-size:160%">잠깐!!!!!!! 😾 👿 💩</span></b>


반복되는 무언가가 보이지 않는가? <b><span style="font-size:130%">🧐</span></b>

dp[n - 1], 즉, ___n번째의 바로 이전 와인까지의 최대량___ 이

n개의 와인을 가지고 최대량을 찾기 위해, 비교하는 수치들에 항상 존재한다!

+ 13에서의 최대값을 찾을 때는,

    + 바로 이전인 10에서의 최대값(6 + 10)이 비교군에 존재하고.

+ 9에서의 최대값을 찾을 때는,
    + 바로 이전인 13에서의 최대값(10 + 23)이 비교군에 존재하고,

+ 8에서의 최대값을 찾을 때는,
    + 바로 이전인 9에서의 최대값(6 + 10 + 9 + 8)이 비교군에 존재하고 있다!

'이전에 구했던 최대값' 이라는 요소에 눈이 뜨이고 나니, 비교하는 다른 수치들에서도 무언가가 보인다!! <b><span style="font-size:130%">🙀</span></b>

---

5개의 와인에서 최대값을 구할 때 수치들을 기억하는가

```
[6, 10, 13, 9, 8]

...... 아악....

6 + 10 + 9 + 8 = 33

10 + 13 + 8 = 31

6 + 13 + 9 = 28 (*)

.... 여기서는 33이 최대값이다...
```

(*) 표시를 한 수식이 바로 이전 요소에서의 최대값울 구하는 수식과 같다.

비교하고 있는 다른 수치들도 보면, 눈에 익은 숫자들이 보인다.
```
'(6 + 10)' + 9 + 8
```
+ 6 + 10은 와인이 2개만 있을 때의 '최대값'이다.
+ 9, 8 은 각각 '현재 요소'와 '이전 요소'의 '와인량'이다.

```
'(10 + 13)' + 8
```
+ 10 + 13은 와인이 3개만 있을 때의 '최대값'이다.
+ 8은 '현재 요소'의 '와인량'이다.

모든 요소에서의 최대값을 구할 때 같은 패턴이 반복되고 있다.

설마,,, 설마,,, 이것을 수식으로 바꿔본다면!!!

<b><span style="font-size:150%">🤘  😾  😣  🥶  💀</span></b>

```
for(int i = 3; i <= wine; i++){

if(dp[i] == 0){
    Math.max(
            Math.max(
                dp[i - 2] + amount[i],
                dp[i - 3] + amount[i - 1] + amount[i]
            ), dp[i - 1];
        )
    }
}
```
---

사실, 

dp문제를 처음 풀어봤기에, 

어느정도 고민을 이어가다,
다른 사람의 코드를 참고했다,,,

문제에 대한 풀이를 적는 지금도 그런 생각이 든다.

아무리 많은 시간을 소모했어도 다른 사람의 코드를 보지않고 스스로 이 패턴을 파악해서 풀이를 구현할 수 있었을까? <b><span style="font-size:130%">😒</span></b>

....

위에서 작성한 것은 bottom-up  <b><span style="font-size:130%">👍</span></b> 방식이다.


dp배열을 초반부터 하나씩 채워나가는 것이 바닥에서 올라가는 것 같지 않은가?

반대로 top-down 방식은 <b><span style="font-size:130%">👎</span></b> 다음과 같다.
```
int recur(int n){
    if(dp[n] == null){
        dp[n] = Math.max(
            Math.max(
                recur(n - 2) + amount[n],
                recur(n - 3) + amount[n - 1] + amount[n]
            ),
            recur(n - 1)
        );
    }

    return dp[n];
}
```

재귀함수를 이용한 것이 바로 top-down방식이다.

매개변수 n을 시작으로 이전 요소를 반복해서 호출하는 것이 높은곳에서 내려가는 모양 같지 않은가?

bottom-up에서 for 반복문 대신 재귀함수를 호출하고 있는 것만 다르기 때문에, 

bottom-up을 구현할 수 있다면, top-down도 구현할 수 있을 것이다.

---

이와 비슷한 문제로 
### 백준의 계단오르기가 있다. <b><span style="font-size:130%">😈 😈 😈</span></b>

[문제 링크](https://www.acmicpc.net/problem/2579) 

구조는 비슷하나 결정적인 곳이 다르다.

계단오르기와 비교하면서 포도주 시식 문제를 본다면,

패턴을 이해하는데 도움이 될 것이다. <b><span style="font-size:130%">🖖 🥺 👌</span></b>



---

### 성능 요약

메모리: 41584 KB, 시간: 248 ms

### 분류

다이나믹 프로그래밍

### 제출 일자

2024년 2월 13일 23:33:31

### 문제 설명

<p>효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.</p>

<ol>
	<li>포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.</li>
	<li>연속으로 놓여 있는 3잔을 모두 마실 수는 없다.</li>
</ol>

<p>효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오. </p>

<p>예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.</p>

### 입력 

 <p>첫째 줄에 포도주 잔의 개수 n이 주어진다. (1 ≤ n ≤ 10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.</p>

### 출력 

 <p>첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.</p>