# 14938 - 서강 그라운드

[문제 링크](https://www.acmicpc.net/problem/14938)

## 로직

해당 문제는 많은 방법으로 접근할 수 있기에, 그것들을 정리하고자 한다.

서강 그라운드 문제에서 가능한 탐색 범위 내에 존재하는 지역을 탐험하여 얻을 수 있는 최대 아이템 갯수를 얻기 위해서는,
`다익스트라, 플로이드 워셜` 이 두 가지 방법을 사용할 수 있다.

다익스트라와 플로이드 워셜은 개념이 제대로 정립되어 있지 않아 로직의 토대를 짜는 것조차 어려웠기에 정리의 필요성을 통감했다.

### 다익스트라

자주 사용하는 로직도 아니었을 뿐더러, 해당 문제에서는 고려해야할 것들이 많았기에 코드를 작성해나가는 것이 수월하지 않았다.

처음 bfs 형식을 적용하기 위해, 각 노드에서 이어져있는 간선의 정보를 입력하는 것도 어떤 형식을 사용할지 고민이 되었다.

```
ArrayList<ArrayList<Integer>> link = new ArryaList<>(); // 리스트 내부에 리스트
ArrayList<Integer>[] link = new ArrayList<>[nodeCnt + 1]; // 배열 내부에 리스트
```

처음에는 위와 같은 형태를 통해 노드와 노드를 연결하는 간선의 정보를 저장하려 했으나, 이는 2차원 배열 상에서 탐색을 할 때나 사용할 수 있는 방식이다.

즉, 1번째 인덱스에 <1, 2> 와 같은 데이터를 가진 ArrayList를 넣는다면, 여기서 다른 ArrayList를 추가하여 <1, 2>, <3, 4>를 1번째 인덱스에 넣는 것이 불가능하다.  

해당 문제에서는 한 점에서 출발하여 다른 점으로 도달하는 여러 간선에 대한 정보를 표시해야 하므로, 하나의 번호에 여러 간선의 정보를 넣을 수 있어야 한다.

따라서 `ArrayList<ArrayList<ArrayList<Integer>>> link` 와 같은 3중 구조를 만들어야 하나의 점에 대해 여러 좌표에 대한 정보를 넣을 수 있게 된다.

이는 배열을 이용해도 마찬가지로 3중 구조를 사용해야하므로, 리스트를 중첩시키거나 배열을 중첩시키는 방향으로는 노드와 간선의 정보를 표현하는 것이 너무나 복잡해져버린다.


따라서 Node 클래스를 만들어서 도착점과 거리 정보를 갖게 하고, 지역 번호를 인덱스와 매칭시켜 사용한다면 바로 아래의 코드 형태로 간단하게 사용할 수 있다.

```
ArrayList<Node>[] link = new ArrayList<>[];
```

또한, 이는 나중에 알게되었지만 해당 서강 그라운드 문제는 단순하게 bfs 방법만을 적용하여 Node를 탐색해나가면, 최대 아이템 갯수를 가져오기가 어렵다.

가능한 범위 내의 모든 지역을 가기 위해서는 Node 클래스에 Compareable 인터페이스를 구현하여 

각 Node를 PrioirtyQueue에 넣었을 때, 거리가 짧은 순서로 정렬이 되도록 만들어야 한다.

처음에는 탐색하기 전에 갈수 있는 곳들을 거리가 짧은 순서로 정렬하는 것이 어떤 의미를 갖는지 파악할 수 없었다.

이해를 돕기 위해 예시를 제시해보겠다.

1, 2, 3, 4번 네 개의 지역이 존재한다고 할 때,
```
1번과 2번이 이어져있고 거리는 10,
1번과 3번이 이어져있고 거리는 2,
2번과 3번이 이어져있고 거리는 3,
2번과 4번이 이어져있고 거리는 3
```
이고 탐색 범위가 11이라면, 1번 -> 3번 -> 2번 -> 4번 경로를 통해 모든 장소에 탐색이 가능해야 하지만

갈 수 있는 거리에 따라 정렬을 하지 않는다면 먼저 1번에서 2번으로 가게 되고, 2번에서 4번으로 가는 길을 탐색하게 된다.

이 때 2번에 대한 방문체크가 되어버리므로 `1번 -> 3번 -> 2번` 경로를 탐색할 수 없게 되는데, 이로인해 4번까지 탐색이 불가능한 것으로 처리가 된다.

```java
for(Node next : link[node.end]) {
				if(!visited[next.end] && limit - (node.dist + next.dist) >= 0){
					pq.add(new Node(next.end, node.dist + next.dist));
				}
			}
```
해당 다익스트라 풀이법의 핵심 코드이다.

node가 현재 위치하고 있는 지역이고, node가 갖고있는 멤버 변수 end는 node에서 갈 수 있는 도착지점이다.

즉, link[node.end]는 현재 위치에서 이어져있는 지역 a가 있을 때, a에서 갈 수 있는 장소들을 next라 칭하고 하나씩 for문을 통해 탐색하는 것이다.

조건문 if를 통해, 현재 위치 node에서 연결된 next, 그리고 next에 연결된 next.end가 방문한 적이 있는지 체크하고, node에서 node.end까지의 거리와 node.end에서 next.end까지의 거리를 더했을 때, 수색 제한 범위 limit보다 거리가 짧다면, next.end 지역까지 갈 수 있다는 것을 표시하기 위해 아래와 같은 객체를 생성하여 우선순위 큐에 넣어준다.

```java
new Node(next.end, node.dist + next.dist) 
```

---

### 플로이드 워셜

플로이드 워셜은 각 지역에서 모든 지역까지의 최소 거리를 구하는 알고리즘 기법이다.

예를들어, a, b, c, d, e 지역이 있다고 할 때,

a에서 b까지의 최소 거리를 구하는 방법으로, a와 b까지의 거리를 먼저 구한 이후, c를 경유한 a와 b까지의 거리를 구해서 비교한다. 

만일 a에서 바로 b까지의 거리보다 a에서 출발한 이후, c를 경유해서 b로 가는 것이 더 짧다면, 최소 거리를 갱신한다.

그러나 갱신한 거리에서 추가로 d를 경유해서 갔을 때가 더 거리가 짧다면 그 거리로 갱신해준다.

이것을 코드로 아주 간단하게 표현하면,

```java
for(int k = 1; k <= nodeCnt; k++) {
				
                for(int i = 1; i <= nodeCnt; i++) {

					for(int j = 1; j <= nodeCnt; j++) {
						
						if(map[i][j] > map[i][k] + map[k][j]) {

                            map[i][j] = map[i][k] + map[k][j];
					
                      }
				}
			}
		}

```

이렇게 표현할 수 있다.

a -> b 와 a -> c -> b를 비교하는 것을 상상해보자.

a와 b는 연결되어있는 선의 길이만 보면 되고, a -> c -> b는 a에서 c로가는 길이와 c에서 b로 가는 길이를 더하면 된다.

그럼 a -> c -> b와 a -> c -> d -> b는 어떻게 비교가 될 수 있는 것일까?

결국 식으로 표현했을 때, a -> c -> b까지의 최소거리와 (a에서 d까지의 최소거리 + d부터 b까지의 최소거리)를 비교하는 것이기 때문에,

자연스럽게 a -> c -> d까지의 거리와 d -> b까지의 거리가 계산되어서 비교에 사용되는 것이다.

<br>