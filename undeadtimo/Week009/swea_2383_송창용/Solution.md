# [모의 SW 역량테스트] 2383 - 점심 식사시간

[문제 링크](https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AV5-BEE6AK0DFAVl)

## 나의 로직 🧐

모두의 든든한 친구!! ___BFS___ 를 사용할 거야!! <b><span style="font-size:145%">😾</span></b>

__탈출!! 탈출!! 탈출!!!__
<b><span style="font-size:165%">🔥🔥🔥</span></b>


<b><span style="font-size:165%">. . . . . .</span></b>


빠르게 식당에 가지 못하고 모두 굶어죽고 말았다....

<b><span style="font-size:165%">☠️💀☠️</span></b>

<br>

## 🙉 특정 위치를 중심으로 거리를 알아야하는 유형을 공략하자! 🙉

<br>

__특정 위치를 중심으로 거리를 알아야 하는 문제는 지금까지 '3번' 보았다.__

+ 이전에 보았던 역량테스트 문제 중 하나가 이런 유형이었다.

    + 자세한 기억은 안나지만 특정 가게를 중심으로 배달 거리를 측정해야하는 문제였다. <b><span style="font-size:165%">🚴‍♂️</span></b>

+ 이 '점심 식사시간' 문제를 풀고 비슷한 유형을 풀어보고 싶어서 찾은 치킨 배달 문제.

    + 치킨집을 기준으로 가까운 집의 거리를 측정해야하는 문제였다.<b><span style="font-size:165%">🍗</span></b>

    + [문제 링크](https://www.acmicpc.net/problem/15686)

+ 그리고 사람들이 각 계단까지의 거리를 측정하여, 계단을 통해 탈출하는 시간을 고려해야하는 이 ___' 점심 식사시간 '___ 문제까지. <b><span style="font-size:165%">🎢</span></b>

<br>

__이 유형의 문제들을 풀 때, 중요한 것은 bfs가 아니라 <b><span style="font-size:140%">조합</span></b> 이었다.__

<br>

## 핵심 로직 ➿ 조합 ➿

조합을 사용해야 한다는 것만 인식하면 간단하다! <b><span style="font-size:165%">🙉</span></b>

라면을 끓일 때, 재료를 넣거나 넣지 않거나.

마니또에게 선물을 주거나 주지 않거나.

PJT 파트너를 고르거나 고르지 않거나!!!

<b><span style="font-size:165%">. . . . . . </span></b>

<br>

이 문제에서는 각 인원을 대상으로, A 계단으로 탈출하거나 B 계단으로 탈출하도록 조합을 구하는 게 중요하다. <b><span style="font-size:165%">🅰️🅱️</span></b>

<br>

__예를 들어,__ 

___이 문제 <b><span style="font-size:165%">'점심 식사시간'</span></b>에서는 조건으로 두 개의 계단만이 주어짐을 명시하고 있다.___

<br>

3명의 사람 1, 2, 3과 a 계단 b 계단이 있다고 한다면, 

+ a 계단으로 1, 2, 3이 탈출하는 경우에서의 총 시간. 
+ a 계단으로 1, 2가 탈출하고, b 계단으로 3이 탈출하는 경우에서의 총 시간.
+ a 계단으로 1 이 탈출하고 b 계단으로 2, 3이 탈출하는 경우에서의 총 시간.

+ <b><span style="font-size:135%">. . . . . . </span></b>

<br>

이렇게 조합을 통해 각 경우를 나누어주고, 해당 경우마다의 탈출 시간을 구해서 최소 시간을 도출해내는 것이 핵심이다.

<br>

<b><span style="font-size:135%">나의 경우, </span></b>
 bfs를 통해 각 사람마다 각 탈출구에 도착하는 시간, 탈출구에 도착해서 탈출하기까지의 시간 등등을 고려하였다.

<br>

<b><span style="font-size:135%">그러나, </span></b> bfs를 사용해서는 
+ 각 개인이 어떤 탈출구로 탈출할지를 명확하게 정할 수 없으며
+ 따라서, 하나의 탈출구를 기준으로 가까운 사람들을 정렬할 수도 없게 되고,
+ 먼저 도착한 사람으로 탈출 시간을 계산하는 것도 불가능 해지며,
+ 어찌어찌 여러 조건문을 통해 구현한다고 하더라도, 최적의 탈출시간을 구하지 못할 가능성이 생긴다.

    + 실제로 나의 경우, 멀리있는 사람을 먼저 고려한다고 하더라도, 3명 이상이 존재하게 되는 시간에서는 임의로 그 숫자를 다음 시간으로 넘기는 방식을 사용했고,

    + 10개의 테스트 케이스에서 8개의 테스트 케이스를 성공했지만,

    + 나머지 2개의 테스트 케이스에서는 최적의 탈출 방법을 찾지 못하여 실패하고 말았다. <b><span style="font-size:135%">🙈</span></b>


---


## 탈출구를 이용하는 사람들 🆘

특정 장소를 기준으로 거리를 계산해야할 때는 '조합'을 사용하면 된다는 것을 알았다.

<br>

<b><span style="font-size:135%">그러나, </span></b>이 점심 식사시간 문제는 그것 외에도 '탈출구'를 사용하는 사람을 제한해주고 시간이 지났을 때 탈출한 인원을 고려하는 것 등의 구현이 쉽지 않다.

<br>

___실제로 다른 사람들의 코드를 참고하였을 때, 다들 탈출구에 대한 탈출 인원을 고려하는 <b><span style="font-size:135%">' 구체적인 로직 '</span></b>이 천차만별이었다.___


<br>

내가 사용한 방법은 각 탈출구 별로 시간을 나타내는 배열을 사용하였다.

```java
int[] exitA_TimeLine = new int[2000];
```

주어진 문제의 조건을 고려하여 최악의 경우에도 

2000초 내에 사람들이 전부 탈출할 것임을 계산하였기에, 

시간을 표현할 배열을 2000크기로 설정하였다.

<br>

만약 2명의 사람이 3초에 4길이 탈출구에 도착한다면 해당 배열 요소는 이렇게 될 것이다.
```java
[0, 0, 0, 2, 2, 2, 2, 0, 0, 0, 0, ....]
```

인덱스를 각 '초'로 생각하여, 그 값은 탈출구를 사용하고 있는 사람들을 나타내는 것이다.

여기서 하나 더 생각해보자.

우선, 1명의 사람이 같은 4길이의 탈출구에 5초에 추가로 도착하였다.

```java
[0, 0, 0, 2, 2, 3, 3, 1, 1, 0, 0, ....]
```

인덱스 5에서 인덱스 8까지 각 정수값이 1씩 추가되었다.

이 때, 한 명의 사람이 같은 탈출구에 6초에 도착하면 어떻게 될까.

```java
이것은 옳지 않은 결과다.
[0, 0, 0, 2, 2, 3, 4, 2, 2, 1, 0, ....]
```

그 사람 또한 탈출구를 사용하게 한다면, `하나의 탈출구는 3명까지만 사용할 수 있다` 는 조건이 붕괴된다.

따라서 6초에 도착한 사람은 1초를 기다렸다가 7초부터 탈출구를 이용해야 한다.

```java
[0, 0, 0, 2, 2, 3, 3, 2, 2, 1, 1, ....]
```

이것을 나는 코드로 이렇게 구현하였다.

```java
// 만약 탈출구에 도착해서 1초후에 탈출하려고 하는데 3명이 이미 사용하고 있으면,
// 사용인원이 3명이 아닐 때까지 기다리도록 해주는 while문이다.
// 기다리는 시간을 저장해줄 변수 m을 먼저 생성한다.
int m = 0;
            
// 탈출구에 도착하고 1초 이후부터 탈출구를 이용하는 사람이,
// 3명이 아니게 될 때까지 1초씩 기다린다.
while(exitA_timeLine[arrive + 1 + m] == 3) {
     m++;
}
             
 // 3명이 아닐 때까지 기다린 이후, 탈출구의 길이만큼 배열에 1씩 추가해준다.
for(int j = arrive + 1; j <= arrive + exit.get(0).get(2); j++) {
    exitA_timeLine[j + m]++;
                 
    // 마지막 탈출자의 마지막 사용시간을 가져와서,
    // A 탈출구의 탈출 시간으로 지정해주었다.
    if(i == exitA.size() - 1 && j == arrive + exit.get(0).get(2)) {
        escapingTimeA = j + m;
     }
 }
```

나름 획기적인 아이디어라 생각했으나, 성능면에서는 좋지 않다.

시간 측면에서는 다른 사람의 코드와 큰 차이는 없었으나, 

<b><span style="font-size:135%">많은 공간을 차지하는 시간 배열을 만들어서 사용하다보니, </span></b> 

남들의 두 배에 가까운 메모리를 소모하게 되었다.

```
평균적으로 다른 사람의 코드는 40000대 초반 정도의 메모리를 소모했으나,
나의 코드는 80000대 후반 정도의 메모리를 소모하였다.
```

따라서, queue 같은 자료구조를 사용하여, 탈출 논리를 구현하는 것이 성능을 볼 때 훨씬 좋다.