package boj_11279_유서현;

public class Main {
	// boj_11279_최대힙

	// 최대 힙 : 널리 잘 알려진 자료구조! 근데 난왜모름?

	// 최대힙 공부
	// 힙 : 완전 이진트리 (각 노드는 2개까지 자식 노드를 가질 수 있음)
	// (마지막 레벨을 제외하고 모든 레벨이 완전히 채워진 트리)
	// 힙은 중복값을 허용
	// 최소값, 최대값을 최대한 빠르게 찾아내기 위해 고안된 자료구조

	// 힙은 최소 힙(Min Heap), 최대힙(Max Heap) 두가지가
	// 최소 힙은 루트노드가 최솟값, 부모노드의 key는 <= 자식노드의 key
	// 최대 힙은 루트노드가 최댓값, 부모노드의 key => 자식 노드의 key

	// 최대 힙 삽입과정
	// 트리의 가장 끝 위치에 데이터를 삽입
	// 걔의 부모노드와 key값을 비교, 클 경우 부모노드와 자리를 교체하는 것을 반복!
	
	// 최대 힙 삭제과정
	// 최상위 노드를 반환하며 삭제 (Queue의 poll() 이랑 비슷하다는데 그게뭐지)
	// 최상위 노드를 삭제 -> 거기에 가장 마지막 위치의 노드를 위치시킨다
	// 삽입과 반대의 과정으로, 자식노드와 비교하며 자리를 교체
	// (좌,우 노드와 비교해서 더 큰값과 자리를 교체)
	// 이렇게 해야 완전이진트리 모양을 유지할 수 있어서 그런건가?
	
	
	
	// 문제읽기
	// x 입력 -> 배열에 x를 넣기 (x는 2^31보다 작다) (왜 이런범위지)
	// 0 입력 -> 배열의 max값을 출력하고, 그 값을 제거
	// 만약 배열이 비었는데 0이 들어오면 0을 출력
	// 이런 프로그램을 구현 (처음에 빈 배열에서 시작)

	// 인풋
	// 연산의 개수 N (1 <= N <= 100,000)
	// 다음 N개의 줄에 x 또는 0 주어짐

	// 아웃풋
	// 0이 주어진 횟수만큼 잘 출력

	// 설계
	// 완전이진트리를 구현한다.
	// 노드의값, 가리킬 왼쪽노드, 가리킬 오른쪽노드 이렇게
	// 삽입, 삭제 메서드도 구현한다.
	// x 들어오면 삽입, 0 들어오면 삭제
	

}